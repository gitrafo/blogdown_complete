---
title: Digit recognition with TensorFlow
author: Petr Schönbauer
date: '2018-11-19'
slug: digit-recognition-with-tensorflow
categories: []
tags:
  - R
  - tensorflow
  - machine learning
draft: true
---



<p>Introduction myself to machine learing with Keras / TensorFlow. This post is based on <a href="https://tensorflow.rstudio.com/keras/">R Studio Keras blog tutorial</a></p>
<div id="what-is-what" class="section level1">
<h1>What is what?</h1>
<ul>
<li>Keras = high-level neural networks API for TensorFlow written in Python</li>
<li>TensorFlow = Python-friendly open source library for numerical computation</li>
<li>Anaconda = Python distribution (platform for data science)</li>
</ul>
<p>Ok, Python, Python, Python - I think I´ll need Python:) to be installed besides R package Keras. It will not be that easy.</p>
<p>First step - install <a href="https://www.anaconda.com/download/">“Anaconda ditribution”</a> - should play well with Keras (Stackoverflow masters say so, so it must be truth:)).</p>
</div>
<div id="r" class="section level1">
<h1>R</h1>
<pre class="r"><code>library(keras)
library(tidyverse)
library(tensorflow)</code></pre>
<p>Install Keras first. By default the CPU-based installation of Keras and TensorFlow is installed. Seems I can use GPU based one too, maybe later.</p>
<pre class="r"><code># install_keras()</code></pre>
</div>
<div id="mnist-digit-recognition-aka-machine-learning-hello-world" class="section level1">
<h1>MNIST digit recognition aka machine learning “Hello world”</h1>
<p>MNIST = Modified National Institute of Standards and Technology database is a large database of handwritten digits that is commonly used for training various image processing systems. <code>dataset_mnist()</code> function will download the dataset.</p>
<pre class="r"><code>mnist &lt;- dataset_mnist()</code></pre>
<pre class="r"><code>mnist %&gt;% glimpse</code></pre>
<pre><code>## List of 2
##  $ train:List of 2
##   ..$ x: int [1:60000, 1:28, 1:28] 0 0 0 0 0 0 0 0 0 0 ...
##   ..$ y: int [1:60000(1d)] 5 0 4 1 9 2 1 3 1 4 ...
##  $ test :List of 2
##   ..$ x: int [1:10000, 1:28, 1:28] 0 0 0 0 0 0 0 0 0 0 ...
##   ..$ y: int [1:10000(1d)] 7 2 1 0 4 1 4 9 5 9 ...</code></pre>
<p>Dataset contains two lists - train and test set.</p>
<ul>
<li><code>train</code> contains 60000 observations (images) for training</li>
<li><p><code>test</code> contains 10000 observation (images) for testing.</p></li>
<li><code>x</code> is a 3D array - no. of image, width, height</li>
<li><p><code>y</code> is a 1D array - corresponding digit (class)</p></li>
</ul>
<p>3D array is basically set of matrices. Each image is described by 28x28 matrix. Each point represent pixel. The value represent color in greyscale range of 0-255.</p>
<p>For example, code below indexes first 20x10 pixels of 3rd image from <code>train</code> set. We can recognize piece of digit 4.</p>
<pre class="r"><code>mnist$train$x[3, 1:20, 1:10]</code></pre>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    0    0    0    0    0    0    0    0    0     0
##  [2,]    0    0    0    0    0    0    0    0    0     0
##  [3,]    0    0    0    0    0    0    0    0    0     0
##  [4,]    0    0    0    0    0    0    0    0    0     0
##  [5,]    0    0    0    0    0    0    0    0    0     0
##  [6,]    0    0    0    0    0    0    0    0    0     0
##  [7,]    0    0    0    0   62   81    0    0    0     0
##  [8,]    0    0    0    0  126  163    0    0    0     0
##  [9,]    0    0    0    0  220  163    0    0    0     0
## [10,]    0    0    0    0  222  163    0    0    0     0
## [11,]    0    0    0   46  245  163    0    0    0     0
## [12,]    0    0    0  120  254  163    0    0    0     0
## [13,]    0    0    0  159  254  120    0    0    0     0
## [14,]    0    0    0  159  254   67    0    0    0     0
## [15,]    0    0    0  159  254   85    0    0    0    47
## [16,]    0    0    0  150  253  237  207  207  207   253
## [17,]    0    0    0    0  119  177  177  177  177   177
## [18,]    0    0    0    0    0    0    0    0    0     0
## [19,]    0    0    0    0    0    0    0    0    0     0
## [20,]    0    0    0    0    0    0    0    0    0     0</code></pre>
<pre class="r"><code>mnist$train$y[3]</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code>x_train &lt;- mnist$train$x
y_train &lt;- mnist$train$y
x_test &lt;- mnist$test$x
y_test &lt;- mnist$test$y</code></pre>
<pre class="r"><code># reshape
x_train &lt;- array_reshape(x_train, c(nrow(x_train), 784))
x_test &lt;- array_reshape(x_test, c(nrow(x_test), 784))
# rescale
x_train &lt;- x_train / 255
x_test &lt;- x_test / 255</code></pre>
<pre class="r"><code>y_train &lt;- to_categorical(y_train, 10)
y_test &lt;- to_categorical(y_test, 10)</code></pre>
<pre class="r"><code>model &lt;- keras_model_sequential() 
model %&gt;% 
  layer_dense(units = 256, activation = &#39;relu&#39;, input_shape = c(784)) %&gt;% 
  layer_dropout(rate = 0.4) %&gt;% 
  layer_dense(units = 128, activation = &#39;relu&#39;) %&gt;%
  layer_dropout(rate = 0.3) %&gt;%
  layer_dense(units = 10, activation = &#39;softmax&#39;)</code></pre>
<pre class="r"><code>model %&gt;% compile(
  loss = &#39;categorical_crossentropy&#39;,
  optimizer = optimizer_rmsprop(),
  metrics = c(&#39;accuracy&#39;)
)</code></pre>
<pre class="r"><code>history &lt;- model %&gt;% fit(
  x_train, y_train, 
  epochs = 30, batch_size = 128, 
  validation_split = 0.2
)</code></pre>
<pre class="r"><code>plot(history)</code></pre>
<p><img src="/blog/2018-11-19-digit-recognition-with-tensorflow_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>model %&gt;% evaluate(x_test, y_test)</code></pre>
<pre><code>## $loss
## [1] 0.1014833
## 
## $acc
## [1] 0.9822</code></pre>
<pre class="r"><code>model %&gt;% predict_classes(x_test) %&gt;% head</code></pre>
<pre><code>## [1] 7 2 1 0 4 1</code></pre>
</div>
